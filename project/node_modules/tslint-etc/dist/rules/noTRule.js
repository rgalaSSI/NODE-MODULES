"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rule = void 0;
const tsquery_1 = require("@phenomnomnominal/tsquery");
const Lint = require("tslint");
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        const failures = [];
        const identifiers = tsquery_1.tsquery(sourceFile, "TypeParameter > Identifier[name=/^.$/]");
        identifiers.forEach((identifier) => {
            failures.push(new Lint.RuleFailure(sourceFile, identifier.getStart(), identifier.getStart() + identifier.getWidth(), Rule.FAILURE_STRING, this.ruleName));
        });
        const { ruleArguments } = this.getOptions();
        const [options = {}] = ruleArguments;
        const { prefix } = options;
        if (prefix) {
            const identifiers = tsquery_1.tsquery(sourceFile, "TypeParameter > Identifier[name=/^.{2,}$/]");
            identifiers.forEach((identifier) => {
                const { text } = identifier;
                if (text.indexOf(prefix) !== 0) {
                    failures.push(new Lint.RuleFailure(sourceFile, identifier.getStart(), identifier.getStart() + identifier.getWidth(), Rule.FAILURE_MESSAGE_PREFIX(text, prefix), this.ruleName));
                }
            });
        }
        return failures;
    }
}
exports.Rule = Rule;
Rule.metadata = {
    description: "Disallows single-character type parameters.",
    options: {
        properties: {
            prefix: { type: "string" },
        },
        type: "object",
    },
    optionsDescription: Lint.Utils.dedent `
      An optional object with an optional \`prefix\` property.
      If a \`prefix\` is specified, type parameters without the prefix are forbidden.`,
    requiresTypeInfo: false,
    ruleName: "no-t",
    type: "style",
    typescriptOnly: true,
};
Rule.FAILURE_STRING = "Single-character type parameters are forbidden";
Rule.FAILURE_MESSAGE_PREFIX = (name, prefix) => `Type parameter '${name}' does not have prefix '${prefix}'`;
