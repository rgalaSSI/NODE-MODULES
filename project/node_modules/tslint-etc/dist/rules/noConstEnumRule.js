"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rule = void 0;
const tsquery_1 = require("@phenomnomnominal/tsquery");
const Lint = require("tslint");
const tsutils = require("tsutils");
const ts = require("typescript");
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        const { ruleArguments } = this.getOptions();
        const [options] = ruleArguments;
        const allowLocal = options ? options.allowLocal : false;
        const failures = [];
        const constKeywords = tsquery_1.tsquery(sourceFile, "EnumDeclaration > ConstKeyword");
        constKeywords.forEach((node) => {
            const enumDeclaration = node.parent;
            if (allowLocal &&
                !tsutils.hasModifier(enumDeclaration.modifiers, ts.SyntaxKind.ExportKeyword)) {
                return;
            }
            failures.push(new Lint.RuleFailure(sourceFile, enumDeclaration.getStart(), enumDeclaration.getStart() + enumDeclaration.getWidth(), Rule.FAILURE_STRING, this.ruleName));
        });
        return failures;
    }
}
exports.Rule = Rule;
Rule.metadata = {
    description: "Disallows the use of const enums.",
    options: {
        properties: {
            allowLocal: { type: "boolean" },
        },
        type: "object",
    },
    optionsDescription: Lint.Utils.dedent `
      An optional object with an optional \`allowLocal\` property - which defaults to \`false\`.
      If \`allowLocal\` is \`true\`, only exported const enums are forbidden.`,
    requiresTypeInfo: false,
    ruleName: "no-const-enum",
    type: "functionality",
    typescriptOnly: true,
};
Rule.FAILURE_STRING = "const enum is forbidden";
